---
layout: article
title: Divide-and-Conquer Techniques and Sorting Techniques
tags: alg
category: alg
picture_frame: shadow
use_math: true
---

Algorithm Design & Analysis  
**[Sub3] Divide-and-Conquer Techniques and Sorting Techniques**

<!--more-->

## [주제 3] 

- Divide-and-Conquer Techniques and Sorting Techniques

### Algorithm Design Techniques

- Divide-and-Conquer Method
- Dynamic Programming Method
- Greedy Method
- Backtracking Method
- Local Search Method
- Branch-and-Bound Method
- Etc.

### The Divide-and-Conquer Approach

- 1. **Divide** an instance of a problem into one or more smaller instances.

     문제의 인스턴스를 하나 이상의 작은 인스턴스로 나눕니다.

- 2. **Conquer** (Solve) each of the smaller instances. Unless a smaller instance is sufficiently small, use recursion to do this.

     각 작은 인스턴스를 정복합니다. 작은 인스턴스가 충분히 작지 않으면 재귀적을 사용하여 이 작업을 수행합니다.

- 3. If necessary, **combine** the solutions to the smaller instances to obtain the solution to the original instance.

     필요한 경우 작은 인스턴스에 대한 솔루션을 결합하여 원래 인스턴스에 대한 솔루션을 확보합니다.

![image](https://user-images.githubusercontent.com/46957634/122663646-2c84b300-d1d7-11eb-8794-6b356dce4a7b.png)

### Recursion

- Tower of Hanoi
  - [Geeksforgeeks](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/) 
  - ![image](https://user-images.githubusercontent.com/46957634/122663711-81c0c480-d1d7-11eb-99c8-76837c5120cf.png)
- - $T(n) = 2T(n-1) +1, n>1$, $T(1) = 1$
- Recursive thinking!
  - [princeton](https://introcs.cs.princeton.edu/java/23recursion/)
  - ![image](https://user-images.githubusercontent.com/46957634/122663720-88e7d280-d1d7-11eb-8b35-1590e32b0406.png)

### Sorting

>  A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.
>
>  Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐
>
>  일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)

- Problem: 

  - Given a list of n items, arrange them **in a certain order.**
    - Ex: non-increasing, non-decreasing, or etc.

- Some criteria for choosing a sorting algorithm 

  > - How many items will you be sorting? 
  >   얼마나 많은 원소를 정렬할 것인가?
  >
  > - Will there be duplicate items in the data?
  >   데이터에 중복 항목이 있습니까?
  >
  > - What do you know about the data?
  >   데이터에 대해 알고 계십니까?
  >
  > - Is the data already partially sorted? 
  >
  >   데이터는 이미 부분적으로 정렬되어 있는가?
  >
  > - Do you know the distribution of the items?
  >
  >   품목의 분포를 알고 있습니까?    
  >
  > - Are the keys of items very long or hard to compare? 
  >
  >   항목 키가 매우 길거나 비교하기 어렵습니까?
  >
  > - Is the range of possible keys very small?
  >   가능한 키의 범위가 매우 작습니까?
  >
  > - Do you have to worry about disk accesses?
  >   디스크 액세스에 대해 염려해야 합니까?
  >
  > - Do you need a stable sorting algorithm?
  >   안정적인 정렬 알고리즘이 필요한가?
  >
  > - How much time do you have to write and debug your routine?
  >   루틴을 작성하고 디버깅하는 데 얼마나 많은 시간이 필요합니까?

- ref. [Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005](https://drive.google.com/drive/u/0/folders/1IyehEF9hz96cFu5js6ZWyfR4_Mvk1xb8), 

  - 원래 [링크](http://www2.toki.or.id/book/AlgDesignManual/BOOK/BOOK4/NODE148.HTM) 깨짐

#### A Formal Definition of Sorting

- A **partial order** on a set S is a relation R such that for each a, b, and c in S:
  - $$aRa$$ is true (R is reflexive).
  - $$aRb$$ and $$bRc$$ imply $$aRc$$ (R is transitive)
  - $$aRb$$ and $$bRa$$ imply $$a = b$$ (R is antisymmetric)
- A Linear Order or Total Older on a set $$S$$ is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.
- The sorting problem
  - Given a sequence of $$n$$ elements $$a_1, a_2, ..., a_n$$ drawn from a set having a linear order $$\preceq $$
  - find a permutation $$\Pi = (\pi_1, \pi_2, ..., \pi_n)$$ of $$(1,2,...,n)$$ that will map the sequence into a nondecreasing sequence $a_{\pi_1}, a_{\pi_2},...,a_{\pi_n}$ such that $a_{\pi_1} \preceq a_{\pi_i+1}$ for $1 \leq i < n $
- Ex: $ \leq$ on $\mathbb{Z}$$, $ $\subseteq $ on sets 
- Sorting on data with partial order?
- ref. [이산수학 내용](https://blog.naver.com/1net1/220735043638)

### 1. Merge Sort

- **Problem**: Sort *n* keys in nondecreasing sequence.
- **Inputs**: positive integer *n,* array of keys *S* indexed from 1 to *n*.
- **Outputs**: the array *S* containing the keys in nondecreasing order. 배열 S는 감소하지 않는 순서로 정렬된 key를 갖는다
  1. **Divide** the array into two subarrays each with ~n/2 items.
  2. **Conquer** each subarray by sorting it recursively.
  3. **Combine** the solutions to the subarrays by merging them into a single sorted array.

![image](https://user-images.githubusercontent.com/46957634/122665593-12e96880-d1e3-11eb-81e0-a0d1a78f5680.png)

- A simple implementation

```c++
// Sort a list from A[left] to A[right].
// Should be optimized for higher efficiency!!!

void merge_sort(item_type *A, int left, int right){
    int middle;
    if (left < right){
      	//divide : O(1)
        middle = (left + right) / 2;            					
      	//conquer : 2T(n/2)
        merge_sort(A, left, middle);
        merge_sort(A, middle + 1, right);
				//combine : O(n)
      	merge(A, left, middle, right);
    }
}

item_type *buffer; 
// extra space for merge sort, allocated beforehand

void merge(item_type *A, int left, int middle, int right){
    int i, i_left, i_right;
    memcpy(buffer + left, A + left, sizeof(item_type) * (right - left + 1));
		//O(r-l+1), O(n)
  	i_left = left;
    i_right = middle + 1;
    i = left;

    while ((i_left <= middle) && (i_right <= right)){
        if (buffer[i_left] < buffer[i_right])
            A[i++] = buffer[i_left++];
        else
            A[i++] = buffer[i_right++];
    }
    while (i_left <= middle)
        A[i++] = buffer[i_left++];
    while (i_right <= right)
        A[i++] = buffer[i_right++];
}
```

- An example of merging two arrays

| k    | left        | right       | merged                  |
| ---- | ----------- | ----------- | ----------------------- |
| 1    | 10 12 20 27 | 13 15 22 25 | 10                      |
| 2    | 10 12 20 27 | 13 15 22 25 | 10 12                   |
| 3    | 10 12 20 27 | 13 15 22 25 | 10 12 13                |
| 4    | 10 12 20 27 | 13 15 22 25 | 10 12 13 15             |
| 5    | 10 12 20 27 | 13 15 22 25 | 10 12 13 15 20          |
| 6    | 10 12 20 27 | 13 15 22 25 | 10 12 13 15 20 22       |
| 7    | 10 12 20 27 | 13 15 22 25 | 10 12 13 15 20 22 25    |
| -    |             |             | 10 12 13 15 20 22 25 27 |



##### Worst-case time complexity

- 편의상 $n=2m$이라 할 경우 ( $m \in Z^+ \cup \{0\}$)

  - $T(n) = 2T(\frac {n} {2}) + cn, n \geq 2$

    - 2 : Number of subproblems
    - $\frac n 2$ : Subproblem size

  - $T(1) =1 $

    $\rightarrow T(n) = O(nlogn)$

| Merge Sort |                 |         |
| ---------- | --------------- | ------- |
| Divide     | Conquer         | Combine |
| $O(1)$     | $2T(\frac n 2)$ | $O(n)$  |

- *n*개의 원소를 *k*개와 *l*개로 나누어 진행한다고 가정하면 ($$n=k+l$$),
  - $$T(n) = T(k) + T(l) + cn (k \approx l)$$
  - $$n = 2^m$$ 이 아닌 일반적인 경우에도 같은 시간 복잡도를 가짐을 증명할 수 있음.

#### Solving Recurrence Equations

- \- Solve the following recurrences $T(n)$ for given  $T(1)=1$

  \- 1. $T(n) = aT(n-1) + bn$

  \- 2. $T(n) = T(n/2) + bnlog n $

  \- 3. $T(n) = aT(n-1) + bn^2$

  \- 4. $T(n) = aT(n/2) + bn^2$

    \5. $T(n) = T(n/2) + clog n $

    \6. $T(n) = T(n/2) + cn $

    \7. $T(n) = 2T(n/2) + cn $

    \8. $T(n) = 2T(n/2) + cnlogn $

    \9. $T(n) = T(n-1) + T(n-2)$, for $T(1) = T(2) = 1$

#### Some Derivations

1. $T(n) = 2 T(n/2) + cn$, $T(1) = 1$

   - assume $n=2^m$, i.e., $m = log_2 m$ for some $m \geq 0, m \in \mathbb{Z}$

   - $T(2^m) = 2T(2^{m-1})+c \cdot 2^m$

     $= 2 \{2T(2^{m-2})+c \cdot 2^{m-1} \}+c \cdot 2^m$

     $=2^2 \cdot T(2^{m-2})+2 \cdot c \cdot 2^m$

     $= 2^2 \{2 \cdot T(2^{m-3})+c \cdot 2^{m-2} \}+2 \cdot c \cdot 2^m$

     $ ... = 2^m \cdot T(2^0) + m \cdot c \cdot 2^m $

     $ = n \cdot 1 + (log_2 n) \cdot c \cdot n = O(nlog n )$

2. $T(n) = T(n-1) + cn$, $T(1) = 1$

3. $T(n) = 2 T(n/2) + cn^2$, $T(1) = 1$

   - Assume $n=2^m$ for some $m \in \mathbb{Z} - \mathbb {Z^-}$

   - $2 \cdot T (2^{m-1}) + c \cdot 2 ^2m$

     $ = 2 \{ 2 \cdot T(2^{m-2}) + c \cdot 2 ^{2(m-1)} \} + c \cdot 2 ^2m $

     $= 2^2 \cdot T(2^{m-2}) + c \{ 2^{2m-1} + 2 ^{2m}\} $

     $ = 2 \{ 2 \cdot T(2^{m-3}) + c \cdot 2 ^{2(m-2)} \} + c \{ 2^{2m-1} + 2^{2m} \} $

     $= 2^3 \cdot T(2^{m-3})+ c \{ 2^{2m-2} + 2^{2m-1} + 2 ^{2m}\} $

     $ … = 2^m + 2 \cdot c \cdot 2^{2m} - 2 \cdot c \cdot 2^m$

     $ =2 \cdot c \cdot n^2 - (2 \cdot c -1) n = O(n^2)$

   

#### Another Implementation of Merge Sort

- ref. [Horowitz 7.6.3]

```c++
int rmerge(element list[], int lower, int upper){
/*sort the list, list[lower], ..., list[upper]. the link field in each record is initially set to -1*/
// list[lower], …, list[upper]까지 오름차순으로 정렬.
// 각 레코드의 link filed는 초기에 -1로 설정
	int middle;
  if (lower >= upper) return lower;
  else{
    middle = (lower + upper)/2;
    return listmerge(list, rmerge(list,lower,middle), rmerge(list, middle+1, upper));
  }
}
```

- $rmerge$ returns an integer that points to the start of the sorted list. start = rmerge(list, 0, n-1);

```
typedef struct {
   int key;
   int link;
} element;
```

```c++
int listmerge (element list[ ], int first, int second){
// first와 second가 가리키는 서브리스트들을 합병
  int start = n;
  while (first != -1 && second != -1) {
    if (list[first].key <= list[second].key) {
      list[start].link = first; 
      start = first;
      first = list[first].link;
    }
    else {
      list[start].link = second; 
      start = second;
      second = list[second].link;
    } 
  }if (first == -1)
    list[start].link = second;
  else list[start].link = first;
  return list[n].link; 
  // 합병된 리스트의 시작 인덱스를 return
}
```



- $listmerge$ takes two sorted chains, first and second, and returns an integer that points to the start of a new sorted chain that includes the first and second chains.

- listmerge 함수 수행 예 start

  ![image](https://user-images.githubusercontent.com/46957634/122666037-f6026480-d1e5-11eb-8a0a-74b195d732fa.png)

### 2. Quick Sort

- Pivot strategy

- 1 **Divide**

  - Select a **pivot element**, and then divide the array into two subarrays such that ....

- 2 **Conquer**

  - sort each subarray recursively. 

- 3 **Combine**

  - do nothing.

  ![image](https://user-images.githubusercontent.com/46957634/122666063-0d415200-d1e6-11eb-9b54-9cb6c1a6f4f0.png)

- A simple implementation

```c++
// Sort a list from A[left] to A[right].
// Should be optimized for higher efficiency!!!

void **quick_sort
